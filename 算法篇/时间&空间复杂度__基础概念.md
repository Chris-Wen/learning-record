算法基础概念篇
=======

> **算法**

> 1、算法是对待定问题求解步骤的一种描述

> 2、衡量算法的指标：

>　　　　时间复杂度：`执行这个算法需要消耗多少时间，即算法计算执行的基本操作次数`

>　　　　空间复杂度：这个算法需要消耗多少空间，即`算法在运行过程中临时占用存储空间大小的度量，强调的是辅助空间的大小`（对数据进行操作的工作单元和存储一些计算的辅助单元），而不是指所有数据所占用的空间

>　　3、同一个问题可以用不同的算法解决，而一个算法的优劣将影响到算法乃至程序的效率。算法分析的目的在于为特定的问题选择合适的算法。一个算法的评价主要从时间复杂度和空间复杂度来考虑

　　　　算法在时间的高效性和空间的高效性之间通常是矛盾的，通常我们会假设程序运行在足够大的内存中，更多地去探究时间复杂度


> **时间复杂度与空间复杂度**

- *时间复杂度*

    通用方法：__大O符号表示法__，即 `T(n)=O(f(n))` f(n) 表示每行代码执行次数之和，而 O 表示正比例关系，这个公式的全称是：__算法的渐进时间复杂度__。
    ```javascript
    for(var i=1; i<=n; i++) {
        j = i;
        j++;
    }
    ```
    通过 __大O符号表示法__，这段代码的时间复杂度为：O(n)
    
    继续看上面的例子，假设每行代码的执行时间都是一样的，我们用 1颗粒时间 来表示，那么这个例子的第一行耗时是1个颗粒时间，第二行的执行时间是 n个颗粒时间，第三行的执行时间也是 n个颗粒时间（符号，暂时忽略），那么总时间就是 1颗粒时间 + n颗粒时间 + n颗粒时间 ，即 (1+2n)个颗粒时间，即： T(n) = (1+2n)*颗粒时间，从这个结果可以看出，这个算法的耗时是随着n的变化而变化，因此，我们可以简化的将这个算法的时间复杂度表示为：`T(n) = O(n)`

    常见的时间复杂度量级有：
    - 常数阶`O(1)`
        ```java
        int sum = 0, n = 100;       /*执行一次*/  
        sum = (1 + n) * n / 2;      /*执行一次*/  
        printf("%d",sum);           /*执行一次*/  
        ```
        - 无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1)

    - 对数阶`O(logN)`
        ```java
        int count = 1;        
        while (count < n){  
            count = count * 2;  
            /*时间复杂度为O(1)的程序步骤序列*/  
        } 
        ```
        - 由于每次count乘以2之后，就距离n更近了一分。 也就是说，有多少个2相乘后大于n，则会退出循环。 由2^x=n 得到x=log2n。 所以这个循环的时间复杂度为O(log2n)。因此这个代码的时间复杂度为：`O(logn)`

    - 线性阶`O(n)`
        ```js
        for(var i=0; i<n; i++) {
            ...
        }
        ```
        - 基础for循环里面的代码会执行n遍，因此它消耗的时间是随着n的变化而变化的，因此这类代码都可以用O(n)来表示它的时间复杂度。

    - 线性对数阶`O(nlogN)`
        ```js
        for(m=1; m<n; m++){
            i = 1;
            while(i<n){
                i = i * 2;
            }
        }
        ```
        - 线性对数阶O(nlogN) 其实非常容易理解，将时间复杂度为O(logn)的代码循环N遍的话，那么它的时间复杂度就是 n * O(logN)，也就是了O(nlogN)。

    - 平方阶`O(n²)`
        ``` java
            int i, j;        
            for(i = 0; i < n; i++){  
                for(j = 0; j < n; j++){  
                    /*时间复杂度为O(1)的程序步骤序列*/  
                }  
            }  
        ```
        ```java
        int i, j;        
        for(i = 0; i < n; i++){  
            for(j = i; j < n; j++){   /*注意j = i而不是0*/  
                /*时间复杂度为O(1)的程序步骤序列*/  
            }  
        } 
        //由于当i=0时，内循环执行了n次，当i = 1时，执行了n-1次，……当i=n-1时，执行了1次。所以总的执行次数为: n到1的总和 
        ```
        - 把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²) 了
        
    - 立方阶`O(n³)`
        - O(n) 三次循环，它的时间复杂度就是O(n³)

    - K次方阶`O(n^k)`
        - O(n) K次循环，它的时间复杂度就是O(n^k)

    - 指数阶`O(2^n)`

    上面从上至下依次的时间复杂度越来越大，执行的效率越来越低。
    

- *空间复杂度*

    既然`时间复杂度不是用来计算程序具体耗时的`，那么也应该明白，`空间复杂度也不是用来计算程序实际占用的空间的`。

    `空间复杂度是对一个算法在运行过程中临时占用存储空间大小的一个量度，同样反映的是一个趋势，我们用 S(n) 来定义。`

    空间复杂度比较常用的度量级有：
    - 常数阶`O(1)`
        - 算法执行所需要的临时空间不随着某个变量n的大小而变化，即此算法空间复杂度为一个常量，可表示为 O(1)
    - 线性阶`O(n)`
        ```java
        int[] m = new int[n]
        for(i=1; i<=n; ++i) {
            j = i;
            j++;
        }
        ```
        - 这段代码中，第一行new了一个数组出来，这个数据占用的大小为n，这段代码的2-6行，虽然有循环，但没有再分配新的空间，因此，这段代码的空间复杂度主要看第一行即可，即 S(n) = O(n)

    - 平方阶`O(n²)` ...

    1. 递归情况
    ```java
    int BinarySearch2(const int* ptr,const int x,const int left,const int right)  {  
        int mid=(left+right)/2;  
        while(left<=right)  {  
            if(x<ptr[mid])  {  
                return BinarySearch2(ptr,x,left,mid-1);  
            }  else if(x>ptr[mid])  {  
                return BinarySearch2(ptr,x,mid+1,right);  
            }  
            return mid;  
        }  
    }
    ```
    递归情况下的空间复杂度：递归深度为N*每次递归的辅助空间大小，如果每次递归的辅助空间为常数，则空间复杂度为O(N)。

    对于递归的二分查找，递归深度是log2^n，每次递归的辅助空间为常数，所以空间复杂度为O(log2N)（2为底数下标）
    2. 非递归情况
    在这个过程中，辅助空间为常数级别，所以空间复杂度为O(1)